#RGBカラー変換プログラムを作る。
# 10進数だと R = 65 G = 105 B = 225

#プログラムの仕様
# ・10進数を16進数に変換するto_hexメソッドと16進数を10進数に変換するto_intsメソッドの2つを定義。
# ・to_hexメソッドは3つの整数を受け取り、それぞれを16進数に変換した文字列を返す。文字列の先頭には#をつける。
# ・to_intsメソッドは、RGBカラーを表す16進数文字列を受け取り、R,G,Bそれぞれを10進数の整数に変換した値を配列として返す。

#RGBカラー変換プログラムの実行例

# to_hex(0,0,0) #=>'#000000'

# to_hex(255,255,255) #=>'#ffffff'

# to_hex(4,60,120)#=>'#043c78'

# to_ints("#000000") #=>[0,0,0]

# to_ints("#ffffff") #=>[255,255,255]

# to_ints("#043c78") #=>[4,60,120]

#この章で学ぶこと

# ・配列
# ・ブロック
# ・範囲(Range)
# ・様々な繰り返し処理
# ・繰り返し処理用の制御構造

# 配列・・・複数のデータをまとめて格納できるオブジェクト。配列内のデータ(要素)は順番に並んでいて、
#ナンバー(インデックス)を指定することで、そのデータを取り出すことができる。

# 空の配列を作る
# [] ([]を使って作成することを配列リテラルという)

#3つの要素が格納された配列を作る。
# [要素1,要素2, 要素3]

# 配列はArrayクラスのオブジェクトになっている。
# 空の配列を作成し、そのクラス名を確認する。

puts [].class
#出力結果 Array

# 変数aに1,2,3が格納された配列を代入
 a = [1,2,3]
 puts a
 #出力結果
 1
 2
 3


 # 配列は数値に限らず、どんなオブジェクトでも格納できる。次は配列の中に文字列を格納する。

 a = ["apple","orange","melon"]

 #異なるデータの格納もできる
a = [1, "apple", 2, "orange", 3, "melon"]

#配列の中に配列を含めることもできる。
a = [[10, 20, 30],[40, 50, 60],[70, 80, 90]]

#配列の要素を取得する場合は、[]と添え字(インデックス番号)を指定する最初の要素は0とする。
a = [1, 2, 3]
#1つめの要素を取得
puts a[0]
#出力結果 1

#2つめの要素を取得
puts a[1]
#出力結果 2

#3つめの要素を取得
puts a[2]
#出力結果 3

# 存在しない配列を指定して取得しよう他場合、エラーにならずnilとなる。
a = [1, 2, 3]

puts a[100]
#出力結果 nil

#sizeメソッド(同じメソッド効果のあるエイリアスメソッドだとlength)を使うと配列の長さ(要素の数)を取得できる。

a = [1,2,3]
puts a.size
#出力結果 3 

#要素の変更、追加、削除

#添え字を指定して値を代入すると指定した要素を変更することができる。

#配列[添え字] = 新しい値

#2番目の要素を20に変更するコード例
a = [1, 2, 3]
a[1] = 20

puts a
#出力結果
1
20
3

# 元の値より大きい添え字を指定すると、間の値がnilで埋められる。以下の例は元の要素数が3の配列に対して、5番目の要素を設定した実行結果。4番目が飛ばされたので、nilとなる。
 a = [1, 2, 3]
 a[4] = 50

 puts a
 #出力結果
 1
 2
 3
 #nil
 50

# <<を使うと配列の最後に要素を追加することができる。
a = []
a << 1
a << 2
a << 3

puts a
#出力結果
1
2
3

#配列内の特定の位置にある要素を削除したい場合は、delete_atメソッドを使います。

a = [1, 2, 3]

#2番目の要素を削除する(削除した値が戻り値になる)
a.delete_at(1)

puts a
#出力結果
1
3

#存在しない添え字を指定してdelete_atしようとしたらnilが返る

#配列を使った多重代入

a, b = 1, 2

a, b = [1, 2]

#右辺の数が少ない場合はnilが入る
c,d = [10]
# c#=>10
# d#=>nil

#配列で書くと [10, nil] の状態

#右辺の値が多い場合ははみ出した値が切り捨てられる。
e,f = [100, 200, 300]
# e#=>100
# f#=>200
#配列で書くと[100, 200]の状態

#divmodメソッド・・・割り算の商と余りを配列として返すメソッド

puts 14.divmod(3)
#商が4で余りが2
#出力結果 [4, 2]

#戻り値を配列のまま受け取る
quo_rem = 14.divmod(3)
puts "商=#{quo_rem[0]},余り=#{quo_rem[1]}"
#出力結果 商=4,余り=2

#多重代入多重代入で別々の変数として受け取る
quotient, remainder = 14.divmod(3)
puts "商=#{quotient},余り=#{remainder}"
#出力結果  商=4, 余り=2

