#ブロック・・・メソッドの引数として渡すこのできる処理の塊。
#ブロック内で記述された処理は、必要に応じてメソッドから呼び出される。

 #eachメソッド・・・配列の要素を最初から最後まで順番に取り出すこと。

 #配列の要素を順番に取り出す作業はeachメソッドで行い、その要素をどう扱うかは、ブロックに記述します。
 #doからendまでがブロックになる。|n|のnはブロック引数と呼ばれるもので、eachメソッドから渡された配列の要素が入ります。
 #具体的に言うと、nには1、2、3、4が順番に渡されます。ブロックの内部では自由にRubyのコードが書けます。
 #ここではsum+=nのように、変数sumに配列の各要素nを加算するコードを書きました。結果として、配列の中身を順に加算していくコードを書いたことになります

 numbers = [1, 2, 3, 4]
 sum = 0
 
 numbers.each do |n|

  sum += n

 end

 puts sum
#出力結果10

 # each以外の使用例
 
 a = [1, 2, 3, 1, 2, 3]
 #配列から値が2の要素を削除する
 a.delete(2)
puts a 
#出力結果 [1, 3, 1, 3]

#deleteメソッドを使うと引数で渡した値に完全一致する要素しか削除できない。例えば、奇数だけ削除などの処理ができない。
#こういった場合は、deleteメソッドではなくdelete_ifメソッドを使って、奇数だけ削除することができる。
a = [1, 2, 3, 1, 2, 3 ]
a.delete_if do |n|
  n.odd?
end

#ブロック引数nに1,2,3,1,2,3が順番に渡されている。delete_ifメソッドはブロックの戻り値をチェックする。
#戻り値が真(true)であれば、ブロックに渡した要素を配列から削除する。偽であれば配列に残したままにする。
#ブロックの戻り値は、メソッドと同様、最後に評価された式になります。上のコードでは、n.odd?の結果が戻り値となっている。

#ブロック引数とブロック内の変数
#ブロック引数の名前は自由に決めることができる。

numbers = [1, 2, 3, 4]
sum = 0

numbers.each do |n|
  #三項演算子を使っている。条件式 ? 真の時の値 : 偽の時の値,ここの場合だとブロック引数nに順番にnumberに格納されている配列を代入していき、偶数だとtrueになるので、
  #n*10の計算。偽だとnをそのまま返す。その後sum_valueの変数に代入
  sum_value = n.even? ? n* 10 : n
  sum += sum_value
end
puts sum
#出力結果 64

#ブロック内で初めて登場した変数のスコープ範囲は、ブロック内部(do~end)のみとなる。ブロック外で使用するとエラーになる。
#一方sumのようにブロック外部で作成されたローカル変数はブロックの内部でも参照できる。
#ブロック引数の名前をブロックの外にある変数の名前と同じにすると、ブロック引数の値が優先して参照される。
#(名前の重複により他の変数、メソッドが参照できなくなることをシャドーイング)という。同じにならないように注意する。

# do ... end と {}

#ブロックは改行を入れなくても動作する。
numbers = [1, 2, 3, 4]
sum = 0
numbers.each do |n| sum += n end
puts sum
#出力結果10

#do ... endの代わりに{}でもブロックを作ることができる。
numbers = [1, 2, 3, 4]
sum = 0
numbers.each { |n| sum += n }
puts sum
#出力結果10

#書き分けの判断としては、長いブロックを書くときは do ... end 1行でコンパクトに書きたいときは {}を使う。

#使用頻度が高いブロックを使う配列のメソッド
# ・map/collect
# ・select/find_all/reject
# ・find/detect
# ・inject/reduce



#mapメソッドとcollectメソッド・・・各要素に対してブロックを評価した結果を新しい配列にして返す


numbers = [1,2,3,4,5]
#ブロックの戻り値が新しい配列の各要素になる。
new_numbers = numbers.map { |n|
 n * 10
}

puts new_numbers
#出力結果 [10, 20, 30, 40, 50]

#空の配列を用意して、他の配列をループ処理した結果を空の配列に詰め込んでいくような大半の処理は、mapメソッドに置き換えることができる。

#selectメソッドとfind_allメソッド・・・各要素に対してブロックを評価し、その戻り値が真の要素を集めた配列を返すメソッド。例えば偶数だけの配列を作ることできる。
numbers = [1, 2, 3, 4, 5, 6]
#ブロックの要素が真になった要素だけ集められる。
even_numbers = numbers.select { |n|
n.even?
}
puts even_numbers
#出力結果 [2, 4, 6]

#rejectメソッド・・・selectメソッドの反対で、ブロックの戻り値が真になった要素を除外した配列を返す。言い換えると、ブロックの戻り値が偽である要素を集めるメソッド。
# numbers = [1, 2, 3, 4, 5, 6]
# #3の倍数を除外する。（3の倍数以外を集める）
# non_multiples_of_three = numbers.reject
#  { |n| n % 3 == 0 }
#  puts non_multiples_of_three
#  #出力結果 [1, 2, 4, 5]

#findメソッドとdetectメソッド・・・ブロックの戻り値が真になった最初の要素を返す。
numbers = [1,2,3,4,5,6]
even_numbers = numbers.find { |n| n.even? }
puts even_numbers
#出力結果 2

#injectメソッドとreduceメソッド・・・たたみ込み演算を行うメソッド。このメソッドの動きは実際のサンプルコードを見ながら動かした方がわかりやすい。
numbers = [1, 2, 3, 4]
sum = numbers.inject(0) { |result, n| result + n }
puts sum
#出力結果 10

#injectメソッドの動き説明・・・ブロックの第1引数(result)は初回のみinjectメソッドの引数(上のコードで0)が入る。
#2回目以降は前回のブロックの戻り値が入る。ブロックの第2引数は配列の各要素(1,2,3,4)が順番に入る。
                          #ブロックの戻り値は次の回に引き継がれ、ブロックの第1引数(result)に入る。繰り返し処理が最後まで終わると、
                          #ブロックの戻り値がinjectメソッドの戻り値となる。

#injectメソッドは数値以外のオブジェクトに対して適用することもできる。
["Mon","Tue","Wed","Thu","Fri","Sat"].inject("Sun") { |result,s | result + s }
#=>"SunMonTueWedThuFriSat"

#ブロックを使うメソッドは
#ブロック引数が1個だけである、
#かつブロックの中で呼び出すメソッドには引数がない、
#かつブロックの中では、ブロック引数に対してメソッドを1回呼び出す以外の処理がない。
#の3つの条件を満たしているときに限って、メソッドにブロックを渡す代わりに、
#&:メソッド名という引数を渡す形に書き換えることができる。

#このコードは
[1,2,3,4,5,6].select{|n|n.odd?}

#=> [1,3,5]

#こう書き換えられる。
[1,2,3,4,5,6].select(&:odd?)

#=>[1,3,5]

#範囲(Range)オブジェクト・・・「1から5まで」「文字"a"から文字"e"まで」のように値の範囲を表すオブジェクト。 .. または ... を使って作成する。

#最初の値..最後の値(最後の値を含む)
#最初の値...最後の値(最後の値を含まない)
# 1..5
# 1...5
# "a".."e"
# "a"..."e"

#範囲オブジェクトはRangeクラスのオブジェクト
(1..5).class
(1...5).class

# ..と...の違いは最後の値を含める含めないかである。

#include?メソッド使って含まれているか含まれていないか確かめる

# ..を使うと5が範囲に含まれる。
range = 1..5

range.include?(0) #出力結果 false
range.include?(1) #出力結果 true
range.include?(4.9) #出力結果 true
range.include?(5) #出力結果 true
range.include?(6) #出力結果 false

# ...を使うと5が範囲に含まれない(1以上5未満)
range = 1...5
range.include?(0) #出力結果 false
range.include?(1) #出力結果 true
range.include?(4.9) #出力結果 true
range.include?(5) #出力結果 false
range.include?(6) #出力結果 false

#変数などに入れずに直接範囲オブジェクトを呼び出す際は..や...の優先順位が低いため、範囲部分を()で囲む必要がある。

(1..5).include?(1) #出力結果 true

#範囲的なオブジェクトを使うと便利な具体的な使用例
#配列や文字列の一部を抜き出す
#配列に対して添え字の代わりに範囲オブジェクトを渡すと、指定した要素の範囲を取得することができる。
a = [1, 2, 3, 4, 5]
#2番目から4番目までの要素を取得する
a[1..3] #出力結果 [2, 3, 4]

#文字列に対しても同じような操作ができる。
a = "abcdef"
#2文字目から4文字目までを抜き出すz
a[1..3] #出力結果 [b,c,d]

# n以上m以下、n以上n未満の判定をする
# n以上m以下、n以上m未満の判定をしたい場合は、<や>=のような記号（不等号）を使うよりも範囲オブジェクトを使ったほうがシンプルに書けます。


# 0度以上100度未満であれば液体、と判定したい
#範囲オブジェクトを使う場合
def liquid?(temperature)
(0...100).include?(temperature)
end
liquid?(-1) #出力結果 false
liquid?(0) #出力結果 true
liquid?(99) #出力結果 true
liquid?(100) #出力結果 false

#範囲オブジェクトをcase文で使う。年齢に応じて料金を判定するメソッド。

def charge(age)
  case age
    #0歳から5歳までの場合
  when 0..5
    0
    #6歳から12歳までの場合
  when 6..12
    300
   #13歳から18歳までの場合
  when 13..18
    600
   #それ以外の場合
  else
    1000
  end
end

puts charge(5)
#出力結果 0
puts charge(20)
#出力結果 1000

# 値が連続する配列を作成する

#範囲オブジェクトに対してto_aメソッドを呼び出すと、値が連続する配列を作成することができる。
# (1..5).to_a #出力結果 [1, 2, 3, 4, 5]
# (1...5)to_a #出力結果 [1, 2, 3, 4]

("a".."e").to_a #出力結果 ["a","b", "c", "d", "e"]
("a"..."e").to_a #出力結果 ["a","b","c","d"]

("bad".."bag").to_a #出力結果 ["bad", "bae", "baf", "bag"]
("bad"..."bag").to_a #出力結果 ["bad", "bae", "baf"]

# []の中に*と範囲オブジェクトを書いても同じように配列を作ることができる。(*を使って複数の値を配列に展開することをsplat展開という)
[*1..5] #出力結果 [1, 2, 3, 4, 5]
[*1..5] #出力結果 [1, 2, 3, 4]

#繰り返し処理を行う
#範囲オブジェクトを配列に変換すれば、配列として繰り返し処理を行うことができる。

numbers = (1..4).to_a
sum = 0
numbers.each { |n|
 sum += n
}

puts sum #出力結果 10

#配列に変換しなくても範囲範囲オブジェクトに対して直接eachメソッドをよびメソッドを呼び出すこともできる。
sum = 0
(1..4).each { |n|
sum += n
}

puts sum #出力結果 10

# stepメソッドを呼び出すと、値を増やす間隔を指定できる。

numbers = []
#1から10まで2つとばしで繰り返し処理を行う
(1..10).step(2) { |n| numbers << n }
puts numbers #出力結果 [1, 3, 5, 7, 9]

#例題:RGB変換プログラムを作成する