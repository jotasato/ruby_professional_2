#to_hexメソッドを作成する。

def to_hex(r, g, b)
  "#000000"
end

0.to_s(16)#=>"0"
255.to_s(16)#=>"ff"

# to_sメソッドで整数を16進数に変換できる。ところが、0の時は1桁の"0"になっている。期待している結果は、"00"のような2桁の文字列である。
#今回の場合はrjustメソッドを使って右寄せすると便利である。第1引数には桁数を指定デフォルトは空白(半角スペース)で桁揃えされるが、第2引数を指定すると
#空白以外の文字列を指定することができる。

"0".rjust(5) #=>"  0"
'0'.rjust(5,'0') #=>"00000"
'0'.rjust(5,'_') #=>"____0"

#このメソッドを使えば、0を2桁の"00"に変換することができる。

0.to_s(16).rjust(2,"0") #=>"00"
255.to_s(16).rjust(2,"0") #>="ff"

def to_hex(r, g, b)
  [r, g, b].inject("#") do |hex,n|
  hex + n.to_s(16).rjust(2,"0")
  end
end

#to_intsメソッドを作成する
#16進数の文字列を10進数の数値に変換するメソッド。

# to_ints("000000") #=>[0,0,0]
# to_ints("ffffff") #=>[255,255,255]
# to_ints("#043c78") #=>[4,60,120]

# to_intsメソッドで必要な手順は大きく分けて2つある。
# 文字列から16進数の文字列を2文字ずつ取り出す。
# 2桁の16進数を10進数の整数に変換する。

s = "abcde"
s[1..3] #=> "bcd"
#この方法を利用すると文字列からR(赤),G(緑),B(青)の各値を取り出すことができる。

hex = "#12abcd"

r = hex[1..2] #=> "12"
g = hex[3..4] #=> "ab"
b = hex[5..6] #=> "cd"

#次に考えるのは16進数の文字列を10進数の整数に変換する方法。

"00".hex #=> 0
"ff".hex #=> 255
"2a".hex #=> 42

# mapメソッドはブロックの戻り値を配列の要素にして新しい配列を返すメソッド

  def to_ints(hex)
    r = hex[1..2]
    g = hex[3..4]
    b = hex[5..6]
    [r,g,b].map do |s|
      s.hex
    end
  end
#上のコードのフローは次の通りです。
#引数の文字列から3つの16進数を抜き出す。
#3つの16進数を配列に入れ、ループを回しながら10進数の整数に変換した値を別の配列に詰め込む。
#10進数の整数が入った配列を返す。

#高度なリファクタリング方法
#最初にr、g、bという変数を作って代入していますが、ここは改行せずに多重代入を使って1行にしても、コードの可読性は悪くならないと思います。
def to_ints(hex)
  r,g,b = hex[1..2],[3..4],[5..6]
  [r,g,b].map do |s|
    s.hex
  end
end

#範囲オブジェクトの代わりに正規表現とscanメソッドを使うと、一気に文字列を3つの16進数に分割することができる。
def to_ints(hex)
  r,g,b = hex.scan(/\w\w/)
  [r,g,b].map do |s|
    s.hex
  end
end

# scanメソッドは正規表現にマッチした文字列を配列で返す。（r,g,bに対して多重代入できるのもscanメソッドが配列を返しているためです）。

#'#12abcd'.scan(/\w\w/)#=>["12","ab","cd"]
#なので、一度変数に入れて[r,g,b]のような配列を作らなくても、scanメソッドの戻り値に対して直接mapメソッドを呼ぶことができる。

def to_ints(hex)
  hex.scan(/\w\w/).map do |s|
    s.hex
  end
end

#ブロックをなくし、代わりに&:hexをmapメソッドの引数に渡します。

def to_ints(hex)
hex.scan(/\w\w/).map(&:hex)
end

# 配列に対してもっと詳しく説明

#様々な要素の取得方法

#添え字を2つ使うと、添え字の位置と取得する長さを指定することができる。この場合配列が返ってくる。
#配列[位置,取得する長さ]

#次は2つ目の要素から3つの要素を取り出すコード。
a = [1,2,3,4,5]
a[1,3] #=> [2,3,4]

values_atメソッドを使うと、取得したい要素の添え字を複数指定できる。
a = [1,2,3,4,5]
a.values_at(0,2,4) #=> [1,3,5]

# 配列の長さ-1を指定すれば、最後の要素を取得することができる。
a = [1,2,3]
#最後の要素を取得する
a[a.size - 1] #=> 3

#Rubyでは添え字に負の値が使える。-1は最後の要素、-2は最後から2番目の要素、と言うように指定できるのです。
a = [1,2,3]

#最後の要素を取得する
a[-1] #=> 3

#最後から2番目の要素を取得する
a[-2] #=> 2

#最後から2番目の要素から2つの要素を取得する。
a[-2,2]

#配列にはlastというメソッドがある。これを呼ぶと配列の最後の値を取得できる。引数に0以上の値を渡すと、最後のn個の要素を取得できる。
a = [1,2,3]
a.last #=> 3
a.last(2) #=> [2,3]

#lastの反対のfirstメソッドもあり、これは先頭の要素を取得することができる。
a = [1,2,3]
a.first #=> 1
a.first(2) #=> [1,2]

#様々な要素の変更方法
#値を変更する場合も負の添え字が使えます。ただし、正の値を使う場合と異なり、元の大きさを超えるような添え字を指定するとエラーになる。
a = [1,2,3]
a[-3] = -10 #=> [-10,2,3]

#指定可能な負の値よりも小さくなるとエラーが発生する
a[-4] = 0 #=> IndexError:index4toosmallforarray;minimum:3


#開始位置と長さを指定して要素を置き換えることもできる。
a = [1,2,3,4,5]
#2つ目から3要素文を100で置き換える
a[1,3] = 100
a #=> [1,100,5]

# <<だけでなく,pushメソッドを使っても配列に要素を追加することができる。pushメソッドの場合は複数の値を追加することができる。
a = []
a.push(1) #=> [1]
a.push(2,3) #=> [1,2,3]

#指定した値に一致する要素を削除したい場合はdeleteメソッドを使う。
a = [1,2,3,1,2,3]
#値が2である要素を削除する(削除した値が戻り値になる)
a.delete(2) #=> 2
a #=> [1,3,1,3]

#存在しない値を指定するとnilが返る
a.delte(5) #=>nil
a #=>[1,3,1,3]

#2つの配列を連結したい場合はconcatメソッドか、+演算子を使う。違いは元の配列を変更するかどうか(破壊的メソッドかどうか)という点です。
#concatメソッドを使って、配列を連結すると、元の配列(呼び出した側の配列)が変更される。
a = [1]
b = [2,3]
a.concat(b) #=> [1,2,3]
# aは変更される。(破壊的)
a #=> [1,2,3]

# bは変更されない。
b #=> [2,3]

#一方、+を使うと元の配列を変更せず、新しい配列を作成する。
a = [1]
b = [2,3]
a + b #=> [1,2,3]
#aもbも変更されない(非破壊的)
a #=>[1]
b #=>[2,3]

# どちらも「配列を連結する」という用途は同じですが、破壊的な破壊的な変更は大きなプログラムやフレームワークでは思いがけないところで
# 影響を与えてしまう可能性があるため、「どうしても」という理由以外は+演算子を利用することがおすすめされる。

#配列の和集合、差集合、積集合
#Rubyの配列は、|、-、&を使って、和集合、差集合、積集合を集めることができる。
#|は和集合を求める演算子
#2つの配列の要素を全て集め、重複しないように返している。
a = [1,2,3]
b = [3,4,5]
a | b #=> [1,2,3,4,5]

# -は差集合を集める演算子です。左の配列から右の配列に含まれる要素を取り除きます。
a = [1,2,3]
b = [3,4,5]
a - b #=> [1,2]

# &が積集合を集める演算子です。2つの配列に共通する要素配列に共通する要素を返す。
a = [1,2,3]
b = [3,4,5]
a & b #=> [3]

# |,-,&のいずれも、元の配列は変更しません。(非破壊的)
# Rubyには配列よりも効率的に集合を扱えるSetクラスもあります。本格的な本格的な集合演算をする場合は、配列よりもSetクラスを使う方がいいでしょう。

require "set"

a = Set.new([1,2,3])
b = Set.new([3,4,5])

a | b #=> #<Set: {1,2,3,4,5}>

a - b #=> #<Set: {1,2}>
a & b #=> #<Set: {3}>

#多重代入で残りの全要素を配列として受け取る
#多重代入では左辺の変数よりも右辺の個数が多い場合は、はみ出した値が切り捨てられると説明しました。
#しかし左辺の変数に*をつけると、残りの全要素を配列として受け取ることができる。

e,*f = 100, 200, 300

# e #=> 100
# f #=> [200,300]


# 1つの配列を複数の引数として展開する。
#pushメソッドで複数の要素を一度に展開できると説明したが、1つずつの要素ではなく1つの配列となっていた場合に追加をすると配列の中に配列が作成される。
a = []
b = [2,3]
a.push(1) #=> [1]
 #配列をそのまま追加する
 a.push(b) #=> [1,[2,3]]

 #メソッドの引数に配列を渡すとき、「1つの配列」ではなく、配列を展開して「複数の引数」として渡したい場合は、配列の前に*を置きます（splat展開）。実際にやってみましょう。
 a = []
 b = [2,3]

 a.push(1) #=> [1]

 #配列を*付きで追加する
 a.push(*b) #=> [1,2,3]

 #配列を引数に渡す場合は、「1つの配列」として渡したいのか、「複数の引数」として渡したいのか検討し、後者の場合は*を使って配列を展開できることを覚えておきましょう。

#先ほどのpushメソッドのように、個数に制限のない引数のことを可変長引数という。自分で定義するメソッドで可変長引数を使いたい場合は、
#引数名の手前に*をつける。

# def メソッド名(引数名1,引数名2,*可変長引数)
#  メソッドの処理
# end

#可変長引数は配列として受け取ることができる。
#配列を引数に渡す場合は、「1つの配列」として渡したいのか、「複数の引数」として渡したいのか検討し、後者の場合は*を使って配列を展開できることを覚えておきましょう。

def greeting(*names)
  "#{names.join('と')}、こんにちは！"
end

greeting("田中さん") #=> "田中さん、こんにちは！"

greeting("田中さん","鈴木さん") #=>"田中さんと鈴木さん、こんにちは！"

greting("田中さん","鈴木さん","佐藤さん") #=>"田中さんと鈴木さんと佐藤さん、こんにちは！"

# []のなかに*付きで別の配列を置くと、その配列が展開されて別々の要素になる。これもsplat展開の一種です。
a = [1, 2, 3]

# []のなかにそのまま配列を置くと、配列の配列になる。
# [a] #=> [[1,2,3]]

# *付きで配列を置くと、展開されて別々の要素になる
# [*a] #=> [1, 2, 3]

# これを利用すると、別の配列を要素の一部とする新しい配列を作ることができる。

# a = [1, 2, 3]
# [-1, 0, *a, 4, 5] #=> [-1, 0, 1, 2, 3, 4, 5]

# +を使うこともできるが、＊を使った方が簡潔なコードになる。
a = [1, 2, 3]
[-1, 0] + a + [4, 5] #=> [-1, 0, 1, 2, 3, 4, 5]

# ==で等しい配列かどうか判断する

# 配列の全要素を==で比較し、全て等しい場合に2つの配列は等しいと判断される。

# 配列が等しい場合
[1, 2, 3] == [1, 2, 3] #=> true

# 配列が等しくない場合
[1, 2, 3] == [1, 2, 4] #=> false
[1, 2, 3] == [1, 2]  #=> false
[1, 2, 3] == [1, 2, 3, 4] #=> false

# %記法で文字列の配列を簡単に作る
# 配列は[]を使って作成することが多いが、文字列については％記法の％wまたは％Wを使って作成する方法が用意されている。%記法を使うと、カンマではなく
#空白文字(スペースや改行)が要素の区切り文字となる。 また、文字列をシングルクオートやダブルクオートで囲む必要もないため、結果として[]を使う場合よりもコードが短くなる。

# []で文字列の配列を作成する
["apple", "melon", "orange"] #=> ["apple","melon","orange"]

# %wで文字列の配列を作成する(!で囲む場合)
%w!apple melon orange! #=> ["apple", "melon", "orange"]

# %wで文字列の配列を作成する(丸カッコで囲む場合)
%w(apple melon orange) #=> ["apple", "melon", "orange"]

# 文字列を配列に変換する
#文字列を分解して配列に変更することもできる。 charsメソッド、splitメソッドである。charsメソッドは文字列中の1文字一文字を配列の要素に分解するメソッド。
 "Ruby".chars #=> ["R", "u", "b", "y"]

 # splitメソッドは引数で渡した区切り文字で文字列を配列に分割するメソッド。
"Ruby,JavamPerl,PHP".split(",") #=> ["Ruby", "Java", "Perl", "PHP"]

# 配列に初期値を設定する
# ここまで配列の作成は[]を使ってきましたが、この他にもArray.newを使って作成する方法がある。

# 以下のコードはa = [] と同じ
a = Array.new]
#Array.newに引数を渡すとその個数分の要素が追加される。この時の初期値はnilです。

# 要素が5つの配列を作成する。
a = Array.new(5)
a #=> [nil, nil, nil, nil, nil]
#さらに第2引数を指定すると、nil以外の初期値を設定できる。
a = Array.new(5,0)
a #=> [0,0,0,0,0]

# Array.newではブロックを使って初期値を設定することもできる。ブロックは作成する要素の数だけ呼ばれ、ブロック引数には要素の添え字が渡される。
# 配列にはブロックの戻り値がそれぞれ初期値として設定される。次はブロックを使うコード例です。
#要素数が10で、1,2,3,1,2,3...と繰り返す配列を作る。
a = Array.new(10) { |n| n % 3 + 1 }
a #=> [1,2,3,1,2,3,1,2,3,1]

#ブロックについてもっと詳しく
#添え字付きの繰り返し処理 each_with_indexメソッドを使えば、ブロック引数の第2引数に添え字を渡してくれる。

fruits = ["apple","orange","melon"]
# ブロックひきすうのiには0,1,2と要素の添え字が入る
fruits.each_with_index { |fruit, i| puts "#{i}: #{fruit}" }
#=> 0:apple
 #  1:orange
 #  2:melon

# mapメソッドで繰り返し処理をしつつ、添え字も同時に取得したい時は、mapメソッドとwith_indexメソッドを組み合わせて使う。

fruits = ["apple","orange","melon"]
# mapとして処理しつつ、添え字も受け取る。
fruits.map.with_index { |fruit, i| "#{i}: #{fruit}"}
#=> ["0: apple", "1: orange", "2: melon"]

#添え字を0以外の数値から開始させる為には、with_indexメソッドに引数を渡す。 そうすると添え日が引数で渡した数値から開始する。

fruits = ["apple", "orange", "melon"]

# eachで繰り返しつつ、1から始まる添え字を取得する。
fruits.each.with_index(1) { |fruit, i| puts "#{i}: #{fruit}" }
#=> 1:apple
#    2:orange
#    3:melon

# mapで取得しつつ、10から始まる添え字を取得する。
fruits.map.with_index(10) { |fruit, i|  "#{i}: #{fruit}"}
#=> ["10: apple","11: orange", "12: melon"]

# each_with_indexメソッドにメソッドには引数を渡せない為、each.with_index(1)の形で引数を渡さなければならない。

# with_indexメソッドはeachやmap以外でも使用することができる。
# a = ["apple", "orange", "melon"]
# 名前に"a"を含み、なおかつ添え字が奇数である要素を削除する
fruits.delete_if.with_index { |fruit, i| fruit.include?("a") && i.odd? }
#=> ["apple", "melon"]

 # with_indexメソッドはEnumeratorクラスのインスタンスメソッドである。eachメソッドやmapメソッド,delete_ifメソッドなど繰り返し処理繰り返し処理を行う
 # メソッドの大半は、ブロックを省略して呼び出すと、Enumeratorオブジェクトを返すようになっている。
 
 fruits=['apple','orange','melon']
 # よってwith_indexメソッドが呼び出せる
 # fruits.each#=>#<Enumerator:["apple","orange","melon"]:each>
 # fruits.map#=>#<Enumerator:["apple","orange","melon"]:map>
 # fruits.delete_if#=>#<Enumerator:["apple","orange","melon"]:delete_if>

 # 配列がブロック引数に渡される場合
 # 配列の配列に対して繰り返し処理を実行すると、ブロック引数に配列が渡ってくる。例えば、縦の長さと横の長さを配列に格納し、それを複数用意した配列があったとします。

 dimensions = [[10, 20], [30,40], [50, 60],]
 # これを繰り返し処理すると、配列がブロック引数に渡ってきます。
 # 面積の計算結果を格納する配列
 areas = []
 # ブロック引数が1個であれば、ブロック引数の値が配列になる。
dimensions.each do |dimension|
  length = dimension[0]
  width = dimension[1]
  areas << length * width
end
areas #=> [200, 1200, 3000]

# ブロック引数の値を２個にすると、縦と横の値を別々に受け取ることができる。上のコードよりもシンプルに書くことができる。

dimensions = [[10, 20, 100], [30, 40, 200], [50, 60, 300],]
#3つの値をブロック引数に渡そうとすると、ブロック内は2つしかないので3爪は捨てられる。

dimensions.each do |length, width|
  p[length, width]
end

#=> [10, 20]
#=> [30, 40]
#=> [50, 60]

# ブロック引数が多すぎる場合は、はみ出しているブロック引数はnilとなる。
# lengthとwidthには値が渡されるが、fooとbarはnilとなる。
dimensions.each do |length, width, foo, bar|
  p[length, width, foo, bar]
end

#=> [10, 20, nil, nil]
#=> [30, 40, nil, nil]
#=> [50, 60, nil, nil]

#each_with_indexメソッドでブロック引数を2つ受け取る場合
dimensions = [[10, 20],[30, 40],[50, 60],]

# 一旦配列のまま受け取る
dimensions.each_with_index do |dimension, i|
  # 配列から縦と横の値を取り出す
  length = dimension[0]
  width = dimension[1]
  puts "length: #{length}, width: #{width}, i: #{i}"
end

#=> length: 10,width: 20,i: 0
#=> length: 30,width: 40,i: 1
#=> length: 50,width: 60,i: 2

# 一気にブロック一気にブロック引数で受け取る方法。
# 配列の要素を受け取るブロック引数を()で囲むと、配列の要素を別々の配列の要素を別々引数として受け取ることができる。
dimensions = [[10, 20],[30, 40],[50, 60],]
# ブロック引数を（）で囲んで、ブロック引数を（）で囲んで、配列の要素を別々の引数として受け取る。
dimensions.each_with_index do |(length,width), i|
  puts "length: #{length}, width: #{width},i: #{i}"
end

#=> length: 10, width: 20, i: 0
#   length: 30, width: 40, i: 1
#   length: 50, width: 60, i: 2

# 縦の値、横の値、添え字と3つの値をブロック引数で受け取ることができました。

# ブロックローカル変数
# ブロック引数を;で区切り、続けて変数を宣言すると、ブロック内でのみ有効な独立したローカル変数を宣言することができる。(ブロックローカル変数)
numbers = [1, 2, 3, 4]
sum = 0

# ブロックの外にあるsumとはブロックの外にあるsumとは別物の変数sumを用意する
numbers.each do |n; sum|
# 別物のsumを10で初期化し、ブロック引数の値を計算する。
sum = 10
sum += n
# 加算した値をターミナルに表示する
p sum
end

#=> 11
#   12
#   13
#   14

# ブロックの中で使っていたsumは別物なので、ブロックの外のsumには変化がない
sum #=> 0

#配列には非常に豊富なAPI(メソッド群)が揃っている。自分で頑張ってコードを書かなくても、
#最初から用意されているコード一つで実装が完了するケースも実装が完了するケースもよくある。
#配列の要素をあれこれいじくりまわすようなコードを書きたくなったら、手を動かす前にAPIドキュメントに一通り目を通して使えそうな
#メソッドがないか探してみてください。

# 様々な繰り返し処理
# timesメソッド
# 配列を使わずに単純に、n回処理を繰り返したいという場合はIntegerクラスのtimesメソッドが便利。
sum = 0
#処理を5回繰り返す。nには0,1,2,3,4が入る。
5.times { |n| sum += n }
sum #=> 10
#不要であればブロック引数は省略しても良い

# uptoメソッドdowntoメソッド
# nからmまで数値を1つずつ増やしながら、何かを処理したい場合は、Integerクラスのuptoメソッドを使おう。

a =[]
10.upto(14) {|n| a << n}
a #=> [10,11,12,13,14]

#逆に数値を減らしていきたい場合は、downtoメソッドを使う。
a = []
14.downto(10) { |n| a << n }
a #=> [14, 13, 12, 11, 10]

# stepメソッド
# 1,3,5,7のようにnからmまで数値をx個ずつ増やしながら何かを処理したい場合は、Numericクラスのstepメソッドを使います。stepメソッドは次のような仕様になっている。
# 開始値.step(上限値,1度に増減する大きさ)

# 例えば、1から10まで2つずつ値を増やしながら処理をしたい場合
a = []
1.step(10, 2){|n| a << n }
a #=> [1, 3, 5, 7, 9]

# 10から1まで2つずつ値を減らす場合は次のようになる。
a = []
10.step(1,-2) {|n| a << n}
a#=> [10,8,6,4,2]

# ここまではオブジェクトのオブジェクトのメソッドとブロックをオブジェクトのメソッドとブロックを組み合わせて繰り返しメソッドとブロックを組み合わせて繰り返し処理を
# 実行してきましたが、Rubyには繰り返し用の繰り返し用の構文も用意されている。その1つがwhile文です。while文は指定した処理が真である真である間、処理を繰り返す。

# while 条件式 (真であれば真であれば実行)
# 繰り返したい処理
# end

#以下は、配列の要素数が5つになるまで値を追加するwhile文です。
a = []
while a.size < 5
  a << 1
end

# a#=> [1,1,1,1,1]
#条件式の後ろにdoを入れると1行で書くこともできる。
a = []
while a.size < 5 do a << 1 end
 
a#=> [1,1,1,1,1]

# 修飾子としてwhile文を後ろに置いた方がスッキリかける。
a = []
a << 1 while a.size< 5
a #=> [1,1,1,1,1]

#while文の反対で、条件が条件が偽である間、処理を繰り返すuntil文もある。

# until 条件式 (偽であれば実行)
#　繰り返したい処理
# end

#配列の要素数が3以下になるまで配列の配列の要素を後ろから削除していくコード

a = [10,20,30,40,50]
until a.size <= 3
  a.delete_at(-1)
end

a #=> [10, 20, 30]

# while文もuntile文も書く場合は条件式を間違えたり、条件式の結果が変わらないコードを書いてしまうと、無限ループになってしまうので注意する。

# for文
# 配列やハッシュはfor文で繰り返し処理することもできる。
# for 変数 in 配列やハッシュ
#　 繰り返し処理
# end

numbers = [1,2,3,4]
sum = 0
for n in numbers
  sum += n
end
sum #=> 10

# doを入れて1行で書くことも可能
sum = 0
for n in numbers do sum += n end
sum #=> 10

# Rubyの構文では通常forよりeachを多く使う。

#  loopメソッド・・・あえて無限ループを作りたい場合に使用できるKernelモジュールのメソッド。
while true
  # 無限ループ用の処理
end

# loop do
# 無限ループ用の処理
# end


# 無限ループから脱出する場合はbreakを使う。以下は配列に格納した5つの数値の中からランダムに数値を選び、5が出たタイミングで脱出する無限ループのサンプルコード。

numbers = [1,2,3,4,5]
loop do
# sampleメソッドでランダムに要素を一つ取得する。
n = numbers.sample
puts n
break if  n == 5
end